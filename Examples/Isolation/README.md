# Isolation

This example illustrates how hyper-properties can be used to verify if two transactional isolation levels are equivalent.

Given a desired scope for the number of transactions, the number of database keys, and the number of possible values, script `isolation_rc.py` generates a SMV model that describes the behavior of a database working in the *Read Committed* isolation level, and script `isolation_ser.py` generates a SMV model that describes the behavior of a database implementing *Serializability*. Both these models formalize these isolation levels according to the definitions of [Seeing is Believing: A Client-Centric Specification of Database Isolation](https://doi.org/10.1145/3087801.3087802).

Given a similar scope, script `isolation_spec.py` generates a HyperLTL property that checks if, for all executions satisfying one isolation level where all transactions are eventually committed, there exists at least one execution of another isolation level with the same transactions where all are eventually committed. For example, by running `python HyperLasso.py isolation_3x2x2.hq 4 isolation_rc_3x2x2.smv isolation_ser_3x2x2.smv` we will get a set of 3 transactions defined over 2 keys and 2 values that is possible to commit under *Read Committed*, but not possible to commit under *Serializability*. With a scope of `T` transactions we need to run the model checker with a trace length of at least `T+1` states, otherwise the property will be trivially valid because no set of `T` transactions can commit with less that `T+1` states. Of course, since *Serializability* is strictly stronger than *Read Committed*, checking the property in the opposite direction, for example `python HyperLasso.py isolation_3x2x2.hq 4 isolation_ser_3x2x2.smv isolation_rc_3x2x2.smv`, will never produce a counter-example irrespective of the trace length parameter.